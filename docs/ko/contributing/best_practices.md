# 엔지니어링 원칙, 스타일 및 정확성 가이드

## 원칙 및 협업

- **1방향 vs 2방향 결정을 구분하세요.** 되돌릴 수 있는 결정은 빠르게 반복하고, 되돌릴 수 없는 결정은 신중하게 접근하세요.
- **일관성 > "옳음".** 코드베이스 전반에 걸쳐 일관된 패턴을 선호합니다. 정말 나쁜 것이 있다면 전체적으로 수정하세요.
- **수정할 때는 선택적으로 수정하세요.**
  - 발견한 모든 Best Practice 문제를 수정해야 할 의무는 없습니다.
  - 새로운 나쁜 관행을 도입하지 마세요.
  - 변경 사항이 Best Practice를 위반하는 코드에 닿는다면, 변경의 일부로 수정하세요.
- **기능을 억지로 추가하지 마세요.** 기능을 추가할 때는 인터페이스를 오염시키거나 기술 부채를 쌓지 않도록 논리적으로 재구성하세요.

---

## 스타일 및 유지보수성

### 주석과 가독성

다음 경우에 명확한 주석을 추가하세요:
- 논리적 경계(예: 인터페이스)에서, 독자가 10단계 더 깊이 파지 않아도 되도록
- 가정이 만들어지거나 명확하지 않은/예상치 못한 작업이 수행되는 곳
- 복잡한 흐름/함수
- 시간을 절약할 수 있는 곳 (예: 복잡한 정규식 패턴)

### 에러와 예외

- **조용히 실패하지 말고 크게 실패하세요.**
  - 예: 문서를 조용히 삭제하는 대신 예외를 발생시키고 전파하세요.
- **`try/except`를 남용하지 마세요.**
  - 올바른 논리 수준에 `try/except`를 배치하세요.
  - 명확히 적절하지 않은 경우 예외를 마스킹하지 마세요.

### 타이핑

- 모든 것이 **가능한 한 엄격하게 타입이 지정**되어야 합니다.
- 느슨하게 타입된 인터페이스(예: `run_functions_tuples_in_parallel`의 결과)에는 `cast`를 사용하세요.
  - 타입 체커가 `Any`를 보거나 타입이 너무 느슨할 때만 `cast`하세요.
- 읽기 쉬운 타입을 선호하세요.
  - `dict[tuple[str, str], list[list[float]]]`처럼 밀집된 타입은 피하세요.
  - Pydantic 모델 같은 도메인 모델을 선호하세요:
    - `EmbeddingModel(provider_name, model_name)` (Pydantic 모델)
    - `dict[EmbeddingModel, list[EmbeddingVector]]`

### 상태, 객체 및 경계

- 상태 컨테이너와 객체에 **명확한 논리적 경계**를 유지하세요.
- **config** 객체에는 `db_session` 같은 것을 포함시키지 마세요.
- 다음과 같은 상태 컨테이너는 피하세요:
  - 지나치게 중첩된 것
  - 너무 크고 평평한 것 (판단 필요)
- 상속/OOP보다 **컴포지션과 함수형 스타일**을 선호하세요.
- **변이(mutation) 없음**을 선호하세요 (강력한 이유가 없는 한).
- 상태 객체는 **의도적이고 명시적**이어야 하며, 이상적으로 비변이적이어야 합니다.
- 인터페이스/객체를 사용하여 명확한 책임 분리를 만드세요.
- 명확한 이점이 없을 때는 단순함을 선호하세요:
  - 세마포어 같은 복잡한 메커니즘을 피하세요.
  - 강한 이유 없이는 트리 구조보다 **해시 맵(dict)**을 선호하세요.

### 네이밍

- 변수 이름을 신중하고 의도적으로 지으세요.
- 결정이 어려울 때는 길고 명확한 이름을 선호하세요.
- 소규모의 독립된 유틸리티를 제외하고는 단일 문자 변수를 피하세요.
- 합리적인 경우 호출 스택과 함수 내에서 동일한 객체/이름을 일관성 있게 유지하세요:
  - 좋음: `for token in tokens:`
  - 나쁨: `for msg in tokens:` (토큰을 순회할 때)
- 함수 이름은 코드베이스 검색에 도움이 되도록 **길고 설명적으로** 만드세요.

### 구성에 의한 정확성

- 자체 포함적 정확성을 선호하세요.
  - 호출자가 "올바르게 사용"에 의존하지 말고, 잘못된 사용을 어렵게 만드세요.
- 중복을 피하세요:
  - 함수가 인수를 받는다면, 동일한 인수를 포함하는 상태 객체도 같이 받지 마세요.
- 죽은 코드 없음 (매우 타당한 이유가 없는 한).
- 주석 처리된 코드 없음 (매우 타당한 이유가 없는 한).
- 중복 로직 없음:
  - 공유 로직이 조건문 위에 있을 수 있을 때 브랜치에 복사/붙여넣기 하지 마세요.
  - LLM은 종종 미묘한 중복 로직을 만들어냅니다. 주의 깊게 검토하고 제거하세요.
- 매우 긴 체인 로직의 함수를 피하세요:
  - 재사용되지 않더라도 읽기 쉽도록 단계를 헬퍼로 캡슐화하세요.

---

## 성능과 정확성

- 리소스를 오래 보유하지 마세요:
  - DB 세션
  - 잠금/세마포어
- 객체를 검증하세요:
  - 생성 시, 그리고
  - 사용 직전
- 커넥터 코드 (데이터 → Onyx 문서):
  - 입력에 따라 무한히 증가할 수 있는 인메모리 구조는 주기적으로 크기를 확인해야 합니다.
  - 커넥터가 OOM이 발생하면 (종종 "Celery 작업 누락"으로 나타남), 이것을 먼저 확인하세요.

---

## 저장소 규칙: 코드 위치

| 유형 | 위치 |
|------|------|
| Pydantic 및 데이터 모델 | `models.py` 파일 |
| DB 인터페이스 함수 (지연 로딩 제외) | `db/` 디렉토리 |
| LLM 프롬프트 | `prompts/` 디렉토리 (코드 레이아웃 미러링) |
| API 라우트 | `server/` 디렉토리 |

---

## Pydantic 및 모델링 규칙

- dataclass보다 **Pydantic**을 선호하세요.
- 절대적으로 필요한 경우 `allow_arbitrary_types`를 사용하세요.

---

## 데이터 규칙

- 빈 문자열 센티넬보다 명시적 `None`을 선호하세요 (의도에 따라 다름).
- 명시적 식별자를 선호하세요:
  - 정수 코드 대신 문자열 enum을 사용하세요.
- 매직 숫자를 피하세요. **매직 문자열은 항상 피하세요.**

---

## 로깅

- 생성된 곳에서 로그 메시지를 남기세요.
- 다른 곳에서 로깅하기 위해 로그 메시지를 전파하지 마세요.

---

## 캡슐화

- 다른 클래스/모듈의 비공개 속성/메서드/프로퍼티를 사용하지 마세요.
- "비공개"는 비공개입니다. 그 경계를 존중하세요.

---

## SQLAlchemy 가이드

- 지연 로딩(lazy loading)은 특히 여러 목록 관계에 걸쳐 대규모에서 종종 나쁩니다.
- SQLAlchemy 객체 속성 접근 시 주의하세요:
  - 불필요한 DB 쿼리를 피하는 데 도움이 될 수 있지만,
  - 활성 세션 외부에서 접근하면 실패할 수 있으며,
  - 지연 로딩은 그렇지 않으면 "단순한" 함수에 숨겨진 DB 의존성을 추가할 수 있습니다.

---

## 트렁크 기반 개발과 피처 플래그

- **PR에는 실제 변경이 500줄을 초과하지 않아야 합니다.**
- **자주 main에 병합하세요.** 수명이 긴 피처 브랜치는 병합 충돌과 통합 문제를 만듭니다.
- **증분 배포를 위해 피처 플래그를 사용하세요.**
  - 큰 기능은 플래그 뒤에 작고 출시 가능한 증분으로 병합되어야 합니다.
- **플래그를 단기간만 유지하세요.** 기능이 완전히 배포되면 플래그와 죽은 코드 경로를 즉시 제거하세요.
- **올바른 레벨에서 플래그를 사용하세요.** 비즈니스 로직 깊은 곳보다 API/UI 진입점에서 플래그를 선호하세요.
- **두 플래그 상태 모두 테스트하세요.** 플래그가 켜진 상태와 꺼진 상태 모두에서 코드베이스가 올바르게 작동하는지 확인하세요.

---

## 기타

- 코드에 추가하는 모든 TODO는 해당 TODO의 소유자 이름/사용자명 또는 해당 작업을 참조하는 이슈 번호와 함께 작성해야 합니다.
